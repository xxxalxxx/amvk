#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_ARB_shader_image_load_store : enable

#define WORK_GROUP_SIZE 32
#define MAX_LIGHTS 1024
#define MAX_LIGHTS_PER_TILE 40

// for 255 range multiply by more, since numbers like 0.999 will already be converted to 254 
// avoid negative byte since 7 = 0111 in binary
#define TO_FLOAT(x) (float(x) / 0x7fffffff)
#define TO_UINT(x) uint(x * 0x7fffffff)

struct PointLight {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
};

layout (binding = 0, rgba8) uniform image2D outImage;
layout (binding = 1, rgba16f) uniform readonly image2D imageNormalDepth;
layout (binding = 2, rgba8) uniform readonly image2D imageAlbedo;

layout(binding = 3) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
	vec3 eyePos;
	vec2 textureDimens;
	uint lightCount;
} ubo;

layout (std430, binding = 4) buffer LightsBufferObject {
    PointLight pointLights[];
};


layout (local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

shared uint minDepthInt;
shared uint maxDepthInt;
shared uint visiblePointLightIndices[MAX_LIGHTS];
shared uint visiblePointLightCount;
shared vec2 tilePos;
void main() {

	if (gl_LocalInvocationIndex == 0) {
		vec2 texCoord = vec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy) / ubo.textureDimens;
		tilePos = 2.0 * texCoord - 1.0;
		minDepthInt = 0xFFFFFFFF;
		maxDepthInt = 0;
		visiblePointLightCount = 0;
	}

	memoryBarrierShared();
	barrier();
	
	ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);


	vec4 normalDepth = imageLoad(imageNormalDepth, pixelPos);
	vec3 normal = vec3(normalDepth);
	float depth = normalDepth.w;
    uint depthInt = TO_UINT(depth);

	float d = TO_FLOAT(depthInt);
	atomicMin(minDepthInt, depthInt);
	atomicMax(maxDepthInt, depthInt);

	memoryBarrierShared();
	barrier();


	// total tiles = tileScale * 2
	vec2 tileScale = textureDimens / float(2*WORK_GROUP_SIZE);
	vec2 tileBias = tileScale - vec2(gl_WorkGroupID.xy);

	vec4 c1 = vec4(ubo.proj[0][0] * tileScale.x, 0.0f, tileBias.x, 0.0f);
	vec4 c2 = vec4(0.0f, -ubo.proj[1][1] * tileScale.y, tileBias.y, 0.0f);
	vec4 c4 = vec4(0.0f, 0.0f, 1.0f, 0.0f);

	float minDepth = TO_FLOAT(minDepthInt);
	float maxDepth = TO_FLOAT(maxDepthInt);

	// create view matrix
	vec4 frustumPlanes[6];
	// Sides
	frustumPlanes[0] = c4 - c1; // right
	frustumPlanes[1] = c4 + c1; // left
	frustumPlanes[2] = c4 - c2; // bottom
	frustumPlanes[3] = c4 + c2; // top
	// near, far
	frustumPlanes[4] = vec4(0.0f, 0.0f,  1.0f, -minDepthZ);
	frustumPlanes[5] = vec4(0.0f, 0.0f, -1.0f,  maxDepthZ);

	uint threadCount = WORK_GROUP_SIZE * WORK_GROUP_SIZE;
	uint passCount = (ubo.lightCount + threadCount - 1) / threadCount;
	
	for (uint passIt = 0; passIt < passCount; ++passIt) {
		uint lightIndex = passIt * threadCount + gl_LocalInvocationIndex;
		lightIndex = min(lightIndex, ubo.lightCount);
		
		//if () {
			uint offset = atomicAdd(visiblePointLightCount, 1);
			visiblePointLightIndices[offset] = lightIndex;
		//}

	}

	memoryBarrierShared();
	barrier();
	vec3 color = vec3(0.0);
	/*	
	for (uint lightIt = 0; lightIt < visiblePointLightCount; ++lightIt) {
		uint lightIndex = visiblePointLightIndices[lightIt];
		PointLight light = pointLights[lightIndex];
	}*/

    //uvec2 tilePos = gl_WorkGroupID.xy * gl_WorkGroupSize.xy / ubo.textureDimens;
	uvec2 tileLeftTop = gl_WorkGroupID.xy * gl_WorkGroupSize.xy; 
	uvec2 tileRightBottom = tileLeftTop + 1;

	vec4 albedoColor = imageLoad(imageAlbedo, pixelPos);
	vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
	vec2 dim = vec2(ubo.textureDimens);
	vec4 borderColor = vec4(0.0, 1.0, 0.0, 1.0);
	float l = float(ubo.lightCount);

	vec4 result = vec4(pointLights[0].color, 1.0); 
//albedoColor;

	if (pixelPos.x - tileLeftTop.x < 1) {
		result = borderColor;
	}

	if (pixelPos.y - tileLeftTop.y < 1) {
		result = borderColor;
	}


	imageStore(outImage, pixelPos, result);
}

